# Object Orianted Programing
- Object-oriented programming (OOP) – Adından da anlaşılacağı gibi, programlamada objects kullanır. Object-oriented programming, inheritance, hiding, polymorphism gibi gerçek dünya varlıklarını programlamaya dahil etmeyi amaçlar. OOP'nin ana amacı, verileri ve bu verilere işlem yapan functions'ları bir araya getirerek, bu veriye o function dışında hiçbir kod parçasının erişememesi sağlamaktır.

## Content
- [Class](#class)
- [Objects](#objects)
- [Encapsulation](#encapsulation)
- [Absraction](#absraction)
- [Polymorphism](#polymorphism)
- [Inheritence](#inheritence)
- [Dynamic Binding](#dynamic-binding)
- [Message Passing](#message-passing)
- [Functions generated by complier automatically](#functions-generated-by-complier-automatically)
## Class
- C++'da Object-Oriented programlamaya yol açan yapı taşı, Class'tır. Bu, kendi data members ve member functions'larını içeren, kullanıcı tanımlı bir veri türüdür ve bu sınıfın bir instance'ı oluşturularak erişilebilir ve kullanılabilir. Bir class, bir object için bir taslak gibidir. Örneğin: Cars Class'ını düşünün. Farklı isimlere ve markalara sahip birçok araba olabilir ancak hepsi 4 tekerlek, hız sınırı, yakıt tüketim aralığı gibi bazı ortak özellikleri paylaşacaktır. Bu durumda, Car class'tır ve wheels, speed limits ve mileage onların özellikleridir.

- Bir Class, data members ve member functions'lara sahip olan kullanıcı tanımlı bir veri türüdür.
- Data members, veri değişkenleridir ve member functions, bu değişkenleri manipüle etmek için kullanılan fonksiyonlardır. Bu data members ve member functions bir araya gelerek bir Class'taki object'lerin özelliklerini ve davranışlarını tanımlar.
- Yukarıdaki Car class'ı örneğinde, data member, hız sınırı, yakıt tüketimi vb. olacak ve member functions ise fren yapmak, hızı artırmak vb. olabilir.
- C++'da bir Class'ın, bazı ortak özellikleri ve davranışları paylaşan bir grup object'i temsil eden bir blueprint olduğunu söyleyebiliriz.
- blueprint: Blueprint, bir yapının veya sistemin detaylı planını ve tasarımını gösteren bir çizimdir. Genellikle mimari ve mühendislik alanlarında kullanılan blueprintler, bir binanın veya makinenin nasıl inşa edileceğini veya monte edileceğini adım adım gösterir. Programlamada ise blueprint, bir class'ın, yani nesnenin yapı ve davranışlarının tanımlandığı şablondur. Bu şablon, nesnelerin (objects) nasıl oluşturulacağını, hangi özelliklere (properties) sahip olacağını ve hangi işlevleri (functions) gerçekleştireceğini belirler. Bu nedenle, blueprint terimi, programlamada class'ların tasarımı için kullanılır.

## Objects
- Bir Object, bazı özelliklere ve davranışlara sahip tanımlanabilir bir varlıktır. Bir Object, bir Class'ın instance'ıdır. Bir class tanımlandığında, bellekte herhangi bir alan ayrılmaz ancak instantiate edildiğinde (yani bir object oluşturulduğunda) bellek tahsis edilir.
    ```cpp
    #include <iostream>
    using namespace std;

    class person {
        char name[20];
        int id;

    public:
        void getdetails() {}
    };

    int main() {
        person p1; // p1 is a object
        return 0;
    }
    ```
- Objects, bellekte yer kaplar ve bir kaydın veya bir yapının ya da bir birliğin adresi gibi bir adresle ilişkilidir. Bir program çalıştırıldığında, objects birbirlerine mesajlar göndererek etkileşime girerler. Her object, verileri ve bu verileri manipüle etmek için kodları içerir. Objects, birbirlerinin verileri veya kodları hakkında ayrıntıları bilmek zorunda olmadan etkileşime girebilirler; kabul edilen mesaj türünü ve objectlerin döndürdüğü yanıt türünü bilmek yeterlidir.

## Encapsulation
- Normal terimlerle, Encapsulation, veri ve bilgilerin tek bir birim altında toplanması olarak tanımlanır. Object-Oriented Programming'de Encapsulation, verileri ve bu verileri manipüle eden fonksiyonları bir araya getirme olarak tanımlanır. Encapsulation'a gerçek hayattan bir örnek olarak, bir şirkette farklı bölümler olduğunu düşünelim: muhasebe bölümü, finans bölümü, satış bölümü vb. Finans bölümü tüm finansal işlemleri yönetir ve finansla ilgili tüm verilerin kayıtlarını tutar. Benzer şekilde, satış bölümü tüm satış faaliyetlerini yönetir ve tüm satış kayıtlarını tutar. Şimdi, finans bölümünden bir yetkilinin belirli bir ayın satış verilerini almak istemesi durumu ortaya çıkabilir. Bu durumda, doğrudan satış bölümünün verilerine erişmesine izin verilmez. Önce satış bölümündeki başka bir yetkiliyle iletişime geçmesi ve ardından belirli verileri talep etmesi gerekir. İşte encapsulation budur. Burada, satış bölümünün verileri ve bu verileri manipüle edebilen çalışanlar "satış bölümü" adı altında toplanmıştır.
- Encapsulation aynı zamanda data abstraction veya data hiding'e yol açar. Encapsulation kullanmak verilerin gizlenmesini sağlar. Yukarıdaki örnekte olduğu gibi, satış, finans veya muhasebe gibi herhangi bir bölümün verileri diğer bölümlerden gizlenir.

## Absraction
- Data abstraction, C++'da object-oriented programlamanın en temel ve önemli özelliklerinden biridir. Abstraction, sadece gerekli bilgileri gösterip, ayrıntıları gizlemek anlamına gelir. Data abstraction, verinin arka plan detaylarını veya implementasyonunu gizleyerek, dış dünyaya sadece gerekli bilgileri sağlamayı ifade eder. Gerçek hayattan bir örnek olarak, bir adamın araba sürmesini düşünün. Adam, gaz pedalına basarak arabanın hızının arttığını veya frenlere basarak arabanın durduğunu bilir ama gaz pedalına basmanın hızını nasıl artırdığını, arabanın iç mekanizmasını veya gaz, fren vb. bileşenlerin implementasyonunu bilmez. İşte bu abstraction'dır.

- Classes kullanarak Abstraction: C++'da abstraction'ı sınıflar kullanarak implement edebiliriz. Class, data members ve member functions'ları mevcut erişim belirleyicilerini kullanarak gruplandırmamıza yardımcı olur. Bir class, hangi data member'ın dış dünyaya görünür olacağını ve hangisinin olmayacağını belirleyebilir.

- Header dosyalarında Abstraction: C++'da başka bir abstraction türü de header dosyalarıdır. Örneğin, math.h header dosyasında bulunan pow() metodunu düşünün. Bir sayının kuvvetini hesaplamamız gerektiğinde, math.h header dosyasında bulunan pow() fonksiyonunu çağırır ve argüman olarak sayıları geçiririz, ancak fonksiyonun sayıların kuvvetini hesaplamak için kullandığı algoritmayı bilmemize gerek yoktu

## Polymorphism
- Polymorphism kelimesi "birçok forma sahip olma" anlamına gelir. Basitçe, polymorphism, bir mesajın birden fazla formda görüntülenebilmesi yeteneği olarak tanımlanabilir. Bir kişi aynı anda farklı karakteristiklere sahip olabilir. Bir adam aynı anda hem baba, hem koca, hem de çalışandır. Yani aynı kişi, farklı durumlarda farklı davranışlar sergiler. Buna polymorphism denir. Bir işlem, farklı örneklerde farklı davranışlar sergileyebilir. Bu davranış, işlemde kullanılan veri türlerine bağlıdır. C++, operator overloading ve function overloading'i destekler.

- Operator Overloading: Bir operatörün farklı örneklerde farklı davranışlar sergilemesi sürecine operator overloading denir.

- Function Overloading: Function overloading, tek bir fonksiyon adının farklı türde görevleri yerine getirmek için kullanılmasıdır. Polymorphism, inheritance'ı implement etmekte yaygın olarak kullanılır.

- Örnek: Diyelim ki bazı tamsayıları toplamak için bir fonksiyon yazmamız gerekiyor; bazen 2 tamsayı, bazen de 3 tamsayı. Aynı isme sahip, ancak farklı parametrelere sahip Addition Method'u yazabiliriz. İlgili metod, parametrelere göre çağrılacaktır.

## Inheritence
- Bir class'ın başka bir class'tan özellikleri ve karakteristikleri devralma yeteneğine Inheritance (Kalıtım) denir. Inheritance, Object-Oriented Programming'in en önemli özelliklerinden biridir.

- Sub Class: Başka bir class'tan özellikleri devralan class'a Sub class veya Derived Class denir.

- Super Class: Özellikleri bir sub-class tarafından devralınan class'a Base Class veya Superclass denir.

- Reusability (Yeniden Kullanılabilirlik): Inheritance, “reusability” (yeniden kullanılabilirlik) kavramını destekler, yani yeni bir class oluşturmak istediğimizde ve zaten istediğimiz kodun bir kısmını içeren bir class varsa, yeni class'ımızı mevcut class'tan türetebiliriz. Bunu yaparak, mevcut class'ın alanlarını (fields) ve yöntemlerini (methods) yeniden kullanmış oluruz.
## Dynamic Binding
- Dynamic binding'de, bir fonksiyon çağrısına yanıt olarak çalıştırılacak kod, çalışma zamanında belirlenir. C++'da bunu desteklemek için virtual functions (sanal fonksiyonlar) bulunur. Dynamic binding esnek olduğu için, fonksiyon çağrısını ve tanımını derleme zamanında bağlayan static binding'in dezavantajlarından kaçınılmasını sağlar.
    ```cpp
    // C++ Program to Demonstrate the Concept of Dynamic binding
    // with the help of virtual function
    #include <iostream>
    using namespace std;

    class GFG {
    public:
        void call_Function() // function that call print
        {
            print();
        }
        void print() // the display function
        {
            cout << "Printing the Base class Content" << endl;
        }
    };
    class GFG2 : public GFG // GFG2 inherit a publicly
    {
    public:
        void print() // GFG2's display
        {
            cout << "Printing the Derived class Content"
                << endl;
        }
    };
    int main()
    {
        GFG geeksforgeeks; // Creating GFG's object
        geeksforgeeks.call_Function(); // Calling call_Function
        GFG2 geeksforgeeks2; // creating GFG2 object
        geeksforgeeks2.call_Function(); // calling call_Function
                                        // for GFG2 object
        return 0;
    }
    //Printing the Base class Content
    //Printing the Base class Content
    ```
- As we can see, the print() function of the parent class is called even from the derived class object. To resolve this we use virtual functions.   

    ```cpp
    #include<bits/stdc++.h>
    using namespace std;

    class GFG {
    public:
        void call_Function() // function that call print
        {
            print();
        }
        virtual void print() // using "virtual" for the display function 
        {
            cout << "Printing the Base class Content" << endl;
        }
    };
    class GFG2 : public GFG // GFG2 inherit a publicly
    {
    public:
        void print() // GFG2's display
        {
            cout << "Printing the Derived class Content"
                << endl;
        }
    };
    int main()
    {
        GFG geeksforgeeks; // Creating GFG's object
        geeksforgeeks.call_Function(); // Calling call_Function
        GFG2 geeksforgeeks2; // creating GFG2 object
        geeksforgeeks2.call_Function(); // calling call_Function
                                        // for GFG2 object
        return 0;
    }

    //Printing the Base class Content
    //Printing the Derived class Content
    ```
## Message Passing
- Objects, bilgi göndererek ve alarak birbirleriyle iletişim kurarlar. Bir object için bir mesaj, bir prosedürün yürütülmesi talebidir ve bu nedenle istenen sonuçları üreten alıcı object'teki bir fonksiyonu tetikleyecektir. Message passing, object'in adını, fonksiyonun adını ve gönderilecek bilgileri belirtmeyi içerir.

    ```cpp
    #include <iostream>
    using namespace std;

    // Define a Car class with a method to display its speed
    class Car {
    public:
        void displaySpeed(int speed) {
            cout << "The car is moving at " << speed << " km/h." << endl;
        }
    };

    int main() {
        // Create a Car object named myCar
        Car myCar;

        // Send a message to myCar to execute the displaySpeed method
        int currentSpeed = 100;
        myCar.displaySpeed(currentSpeed);

        return 0;
    }
    ```

## Functions generated by complier automatically
- Default Constructor
- Copy Constructor
- Move Constructors
- Assignment Operator
- Destructor